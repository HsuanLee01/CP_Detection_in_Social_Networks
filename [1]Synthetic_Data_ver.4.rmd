---
title: "Synthetic Data"
author: "Hsuan Lee"
output: pdf_document
---
```{r}
setwd(paste("C:/Users/Hsuan Lee/Desktop/Methodology and Statistics/",
"Changepoints Inference in Relational Event Data of a Social Network/",
"Changepoint-Inference-in-REH-of-a-Social-Network", sep = ""))
```

# Simulate the REH
```{r}
# Install the needed packages

#install.packages("devtools")

#library(devtools)

#devtools::install_version("mvtnorm", version = "1.1-3", repos = "http://cran.us.r-project.org")

#devtools::install_github("TilburgNetworkGroup/remify@1a165e99a0ad784ead08974da86fb2a319f537dc")

#devtools::install_github("TilburgNetworkGroup/remstats@c6ef7c41c6b43891f760d2db7ad390e8035b83dc")

#devtools::install_github("TilburgNetworkGroup/remstimate@5ba940645929c4d9d84a4cf16fab68f8971a1a19")
```

```{r}
#devtools::install_github("mlmeijerink/REHdynamics")
```

```{r}
library(tidyverse)
library(REHdynamics) # generate the REH with CPs
library(remstats) # the formula for REH
library(remify)
library(relevent) # fit REH to REM
```

**REH with no CPs**
```{r}
set.seed(9252568)
```

```{r}
# REH with only inertia statistics
formula <- ~ 1 + remstats::inertia(scaling = "std")

# set up the covariates
covar <- data.frame(id = 1:30, time = 0, z = rnorm(n = 30))

# set up the value of parameters
param.ncp <- list(
  "baseline" = -8.8,
  "inertia" = 0.15)

# create REH with 1 CP
reh_ncp <- list()

rep <- 1 # replication times (number of datasets you wanna get)

for (i in 1: rep){
  reh_ncp[[i]] <- generate(formula = formula, param = param.ncp, M = 10000, covar = covar)
  print(i)
}
```

*Plot the Statistics out*
```{r}
library(matrixStats) # for rowMaxs
```

```{r}
# compute the statistics
out.ncp <- remstats(tie_effects = formula, edgelist = reh_ncp) # also will be used for fitting REM
stat.ncp <- out.ncp[["statistics"]] # extract the statistics from the list

# extract the statistics of inertia
ine_ncp <- stat.ncp[,,"inertia"]

# aggregate the statistics of each time point
ine_ncp.agg.max <- rowMaxs(ine_ncp)
plot(ine_ncp.agg.max, type = "lm")

ine_ncp.agg.mean <- rowMeans(ine_ncp)
plot(ine_ncp.agg.mean, type = "lm")
```





```{r}
data.frame(ine_ncp.agg.max) %>%
  ggplot(aes(x = 1:nrow(data.frame(ine_ncp.agg.max)), y = ine_ncp.agg.max)) +
  geom_line(size = 1) +
  labs(y = "Maximum Statistic of Each Event", x = "Event") +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black", fill = NA))
```






*Test CPs of the aggregated statistics (mean and max)*

1. BOCD: Exact CPs Detection Method
```{r}
library(ocp) # package for BOCD
```

```{r}
BOCD_ine_ncp.agg.mean <- onlineCPD(ine_ncp.agg.mean, getR = T, optionalOutputs = T, truncRlim = 10^-6)
BOCD_ine_ncp.agg.mean[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_ncp.agg.mean)

BOCD_ine_ncp.agg.max <- onlineCPD(ine_ncp.agg.max, getR = T, optionalOutputs = T, truncRlim = 10^-6)
BOCD_ine_ncp.agg.max[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_ncp.agg.max)
```

2. PELT: Exact CPs Detection Method
```{r}
library(changepoint) # package for PELT
```

- Mean
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_ncp.agg.mean <- cpt.var(ine_ncp.agg.mean, method="PELT")
summary(PELT_ine_ncp.agg.mean)

# plot the location of detected CPs
plot(ine_ncp.agg.mean, type="point", col = "black")
abline(v=PELT_ine_ncp.agg.mean@cpts[], col="red")
```

- Max
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_ncp.agg.max <- cpt.var(ine_ncp.agg.max, method="PELT")
summary(PELT_ine_ncp.agg.max)

# plot the location of detected CPs
plot(ine_ncp.agg.max, type="point", col = "black")
abline(v=PELT_ine_ncp.agg.max@cpts[], col="red")
```

3. BS: approximate CPs Detection Method
```{r}
library(changepoint) # package for BS
```

- Mean
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_ncp.agg.mean <- cpt.meanvar(ine_ncp.agg.mean, method = "BinSeg")
cpts(BS_ine_ncp.agg.mean)

# plot the location of CPs
plot(ine_ncp.agg.mean)
abline(v=BS_ine_ncp.agg.mean@cpts[], col="black")
```

- Max
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_ncp.agg.max <- cpt.meanvar(ine_ncp.agg.max, method = "BinSeg")
cpts(BS_ine_ncp.agg.max)

# plot the location of CPs
plot(ine_ncp.agg.max)
abline(v=BS_ine_ncp.agg.max@cpts[], col="black")
```

4. Wild BS
```{r}
library(wbs) # package for WBS
```

- Mean
```{r}
WBS_ine_ncp.agg.mean <- wbs(ine_ncp.agg.mean)
changepoints(WBS_ine_ncp.agg.mean)
plot(WBS_ine_ncp.agg.mean)
```

- Max
```{r}
WBS_ine_ncp.agg.max <- wbs(ine_ncp.agg.max)
changepoints(WBS_ine_ncp.agg.max)
plot(WBS_ine_ncp.agg.max)
```

*Create function that aggregates the top 5% of maximum statistics by timepoints*
```{r}
max_mean_time <- 
  function(statistics,
           # percentage of maximum values contained in the aggregation each timepoint
           percent = 0.05){
  # transpose the matrix to let time point as column
  statistics.transpose <- data.frame(t(statistics))
  
  maxs_mean_time <- 0
  # arrange the order of statistics in each time point
  for (time in 1:nrow(statistics)) {
    # extract the statistics by timepoint
    timepoint <- statistics.transpose[,time]
    # arrange the order of statistics of each timepoint
    stat_order <- data.frame(sort(timepoint, decreasing = T))
    # extract and mean the top 5% maximum statistics of each time point
    maxs_mean_time[time] <- mean(stat_order[1:(percent*nrow(statistics)),1])
  }
  results <- list(means_max.values_each_timepoint = maxs_mean_time)
  return(results)
}
```

*Test CPs of the aggregated statistics (top 5% of maximum statistics by timepoints)*

```{r}
# compute the mean of top 5% of maximum statistics by timepoints
top_ine_ncp <- max_mean_time(ine_ncp, percent = 0.05)$means_max.values_each_timepoint
plot(top_ine_ncp) # plot it out
```

1. BOCD: Exact CPs Detection Method
```{r}
# test the CPs
BOCD_ine_ncp.agg.top <- onlineCPD(top_ine_ncp, getR = T, optionalOutputs = T, truncRlim = 10^-6)
BOCD_ine_ncp.agg.top[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_ncp.agg.top)
```

2. PELT: Exact CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_ncp.agg.top <- cpt.var(top_ine_ncp, method="PELT")
summary(PELT_ine_ncp.agg.top)

# plot the location of detected CPs
plot(top_ine_ncp, type="l", col = "red")
abline(v=PELT_ine_ncp.agg.top@cpts[], col="black")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_ncp.agg.top <- cpt.meanvar(top_ine_ncp, method = "BinSeg")
cpts(BS_ine_ncp.agg.top)

# plot the location of CPs
plot(top_ine_ncp)
abline(v=BS_ine_ncp.agg.top@cpts[], col="black")
```

4. Wild BS
```{r}
WBS_ine_ncp.agg.top <- wbs(top_ine_ncp)
changepoints(WBS_ine_ncp.agg.top)
plot(WBS_ine_ncp.agg.top)
```

*Fit the Data-Driven MW REM on the REH with no CP*

```{r}
# extract the synthetic data with 1 CP (data frmae)
reh_ncp <- reh_ncp[[1]]
```

1. Step 1: compute the optimal lengths of the windows
```{r}
# obtain data-driven window widths
ddwin_ncp <- ddwindows(edgelist = reh_ncp, tie_effects = formula, mintime = 2000, 
		covar = covar)
```

2. Step 2: fit the REM by windows
```{r}
#  fits a moving window relational event model
model_ddwin_ncp <- MWrem(windows = ddwin_ncp$windows, edgelist = reh_ncp, 
		stats = stat.ncp, actors = covar$id, directed = TRUE)
```

3. Step 3: extract the parameters by windows and plot them out
```{r}
# extract the parameters
ddmw_ine_ncp_param <- 1
for (i in 1:length(model_ddwin_ncp)) {
  ddmw_ine_ncp_param[i] <- model_ddwin_ncp[[i]][["coefficients"]][["inertia"]]
}
plot(ddmw_ine_ncp_param, type = "lm") # plot the movement of parameter
```

*Test CPs of the DDMW parameters*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_ddmw_ine_ncp_param <- onlineCPD(ddmw_ine_ncp_param, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ddmw_ine_ncp_param[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ddmw_ine_ncp_param)
```

2. PELT: Exact CPs Detection Method
```{r}
PELT_ddmw_ine_ncp_param <- cpt.var(ddmw_ine_ncp_param, method="PELT")
summary(PELT_ddmw_ine_ncp_param)

# plot the location of CPs
plot(ddmw_ine_ncp_param, type="l", col = "red")
abline(v=PELT_ddmw_ine_ncp_param@cpts[], col="black")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ddmw_ine_ncp_param <- cpt.meanvar(ddmw_ine_ncp_param, method = "BinSeg")
cpts(BS_ddmw_ine_ncp_param)

# plot the location of CPs
plot(ddmw_ine_ncp_param)
abline(v=BS_ddmw_ine_ncp_param@cpts[], col="black")
```

4. Wild BS
```{r}
WBS_ddmw_ine_ncp_param <- wbs(ddmw_ine_ncp_param)
changepoints(WBS_ddmw_ine_ncp_param)
plot(WBS_ddmw_ine_ncp_param)
```

*Fit the Fixed MW REM on the REH with No CP*

1. Step 1: Decide the length of the window, and fit it into REM
```{r}
# maximum time point of the REH
tau <- max(reh_ncp$time)

# specify the length of the window
windows <- REHdynamics::createwindows(2000, tau)

# fit to the REM model
model_fixwin_ncp <- REHdynamics::MWrem(windows, edgelist = reh_ncp, 
                                       stats = stat.ncp,
                                       actors = covar$id, directed = TRUE, 
                                       method = "MLE", model = "tie", ncores = 2)
```

2. Step 2: Extract the parameters by windows and plot them out
```{r}
# extract the parameters
fixmw_ine_ncp_param <- 1
for (i in 1:length(model_fixwin_ncp)) {
  fixmw_ine_ncp_param[i] <- model_fixwin_ncp[[i]][["coefficients"]][["inertia"]]
}
plot(fixmw_ine_ncp_param, type = "point") # plot the movement of parameter
```

*Test CPs of the Fixed MW parameters*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_fixmw_ine_ncp_param <- onlineCPD(fixmw_ine_ncp_param, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_fixmw_ine_ncp_param[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_fixmw_ine_ncp_param)
```

2. PELT: Exact CPs Detection Method
```{r}
PELT_fixmw_ine_ncp_param <- cpt.var(fixmw_ine_ncp_param, method="PELT")
summary(PELT_fixmw_ine_ncp_param)

# plot the location of CPs
plot(fixmw_ine_ncp_param, type="point", col = "red")
abline(v=PELT_fixmw_ine_ncp_param@cpts[], col="black")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_fixmw_ine_ncp_param <- cpt.meanvar(fixmw_ine_ncp_param, method = "BinSeg")
cpts(BS_fixmw_ine_ncp_param)

# plot the location of CPs
plot(fixmw_ine_ncp_param, type = "l")
abline(v=BS_fixmw_ine_ncp_param@cpts[], col="red")
```

4. Wild BS
```{r}
WBS_fixmw_ine_ncp_param <- wbs(fixmw_ine_ncp_param)
changepoints(WBS_fixmw_ine_ncp_param)
plot(WBS_fixmw_ine_ncp_param)
```

**REH with 1 CP**

```{r}
set.seed(9252568)
# REH with only inertia statistics
#formula <- ~ 1 + remstats::inertia(scaling = "std")

# set up the covariates
#covar <- data.frame(id = 1:15, time = 0, z = rnorm(n = 15))

# set up the value of parameters
param.1cp <- list(
  "baseline" = -8.8,
  
  "inertia" = function(t) {
    # set the location of CP
    if(t < 38200) { #5955
      0.18
    } else  {
      0.08}
  }
)

# create REH with 1 CP
reh_1cp <- list()

rep <- 1 # replication times (number of datasets you wanna get)

for (i in 1: rep){
  reh_1cp[[i]] <- generate(formula = formula, param = param.1cp, M = 10000, covar = covar)
  print(i)
}
```

*Plot the Statistics out*
```{r}
# compute the statistics
out.1cp <- remstats(tie_effects = formula, edgelist = reh_1cp) # also will be used for fitting REM
stat.1cp <- out.1cp[["statistics"]] # extract the statistics from the list

# extract the statistics of inertia
ine_1cp <- stat.1cp[,,2]

# aggregate the statistics of each time point
ine_1cp.agg.max <- rowMaxs(ine_1cp)
plot(ine_1cp.agg.max, type = "lm")

ine_1cp.agg.mean <- rowMeans(ine_1cp)
plot(ine_1cp.agg.mean, type = "lm")
```

*Test CPs of the aggregated statistics (mean and max)*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_ine_1cp.agg.mean <- onlineCPD(ine_1cp.agg.mean, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ine_1cp.agg.mean[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_1cp.agg.mean)

BOCD_ine_1cp.agg.max <- onlineCPD(ine_1cp.agg.max, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ine_1cp.agg.max[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_1cp.agg.max)
```

2. PELT: Exact CPs Detection Method

- Mean
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_1cp.agg.mean <- cpt.var(ine_1cp.agg.mean, method="PELT")
summary(PELT_ine_1cp.agg.mean)

# plot the location of detected CPs
plot(ine_1cp.agg.mean, type="point", col = "black")
abline(v=PELT_ine_1cp.agg.mean@cpts[], col="red")
```

- Max
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_1cp.agg.max <- cpt.var(ine_1cp.agg.max, method="PELT")
summary(PELT_ine_1cp.agg.max)

# plot the location of detected CPs
plot(ine_1cp.agg.max, type="point", col = "black")
abline(v=PELT_ine_1cp.agg.max@cpts[], col="red")
```

3. BS: approximate CPs Detection Method

- Mean
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_1cp.agg.mean <- cpt.meanvar(ine_1cp.agg.mean, method = "BinSeg")
cpts(BS_ine_1cp.agg.mean)

# plot the location of CPs
plot(ine_1cp.agg.mean)
abline(v=BS_ine_1cp.agg.mean@cpts[], col="red")
```

- Max
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_1cp.agg.max <- cpt.meanvar(ine_1cp.agg.max, method = "BinSeg")
cpts(BS_ine_1cp.agg.max)

# plot the location of CPs
plot(ine_1cp.agg.max)
abline(v=BS_ine_1cp.agg.max@cpts[], col="red")
```

4. Wild BS

- Mean
```{r}
WBS_ine_1cp.agg.mean <- wbs(ine_1cp.agg.mean)
changepoints(WBS_ine_1cp.agg.mean)
plot(WBS_ine_1cp.agg.mean)
```

- Max
```{r}
WBS_ine_1cp.agg.max <- wbs(ine_1cp.agg.max)
changepoints(WBS_ine_1cp.agg.max)
plot(WBS_ine_1cp.agg.max)
```

*Test CPs of the aggregated statistics (top 5% of maximum statistics by timepoints)*

```{r}
# compute the mean of top 5% of maximum statistics by timepoints
top_ine_1cp <- max_mean_time(ine_1cp, percent = 0.05)$means_max.values_each_timepoint
plot(top_ine_1cp) # plot it out
```

1. BOCD: Exact CPs Detection Method
```{r}
# test the CPs
BOCD_ine_1cp.agg.top <- onlineCPD(top_ine_1cp, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ine_1cp.agg.top[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_1cp.agg.top)
```

2. PELT: Exact CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_1cp.agg.top <- cpt.var(top_ine_1cp, method="PELT")
summary(PELT_ine_1cp.agg.top)

# plot the location of detected CPs
plot(top_ine_1cp, type="point", col = "black")
abline(v=PELT_ine_1cp.agg.top@cpts[], col="red")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_1cp.agg.top <- cpt.meanvar(top_ine_1cp, method = "BinSeg")
cpts(BS_ine_1cp.agg.top)

# plot the location of CPs
plot(top_ine_1cp)
abline(v=BS_ine_1cp.agg.top@cpts[], col="red")
```

4. Wild BS
```{r}
WBS_ine_1cp.agg.top <- wbs(top_ine_1cp)
changepoints(WBS_ine_1cp.agg.top)
plot(WBS_ine_1cp.agg.top)
```

*Fit the Data-Driven MW REM on the REH with 1 CP*

```{r}
# extract the synthetic data with 1 CP (data frmae)
reh_1cp <- reh_1cp[[1]]
```

1. Step 1: compute the optimal lengths of the windows
```{r}
# obtain data-driven window widths
ddwin_1cp <- ddwindows(edgelist = reh_1cp, tie_effects = formula, mintime = 2000, 
		covar = covar)
```

2. Step 2: fit the REM by windows
```{r}
#  fits a moving window relational event model
model_ddwin_1cp <- MWrem(windows = ddwin_1cp$windows, edgelist = reh_1cp, 
		stats = stat.1cp, actors = covar$id, directed = TRUE)
```

3. Step 3: extract the parameters by windows and plot them out
```{r}
# extract the parameters
ddmw_ine_1cp_param <- 1
for (i in 1:length(model_ddwin_1cp)) {
  ddmw_ine_1cp_param[i] <- model_ddwin_1cp[[i]][["coefficients"]][["inertia"]]
}
plot(ddmw_ine_1cp_param, type = "lm") # plot the movement of parameter
```

*Test CPs of the DDMW parameters*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_ddmw_ine_1cp_param <- onlineCPD(ddmw_ine_1cp_param, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ddmw_ine_1cp_param[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ddmw_ine_1cp_param)
```

2. PELT: Exact CPs Detection Method
```{r}
PELT_ddmw_ine_1cp_param <- cpt.var(ddmw_ine_1cp_param, method="PELT")
summary(PELT_ddmw_ine_1cp_param)

# plot the location of CPs
plot(ddmw_ine_1cp_param, type="l", col = "red")
abline(v=PELT_ddmw_ine_1cp_param@cpts[], col="black")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ddmw_ine_1cp_param <- cpt.meanvar(ddmw_ine_1cp_param, method = "BinSeg")
cpts(BS_ddmw_ine_1cp_param)

# plot the location of CPs
plot(ddmw_ine_1cp_param)
abline(v=BS_ddmw_ine_1cp_param@cpts[], col="black")
```

4. Wild BS
```{r}
WBS_ddmw_ine_1cp_param <- wbs(ddmw_ine_1cp_param)
changepoints(WBS_ddmw_ine_1cp_param)
plot(WBS_ddmw_ine_1cp_param)
```

*Fit the Fixed MW REM on the REH with One CP*

1. Step 1: Decide the length of the window, and fit it into REM
```{r}
# maximum time point of the REH
tau <- max(reh_1cp$time)

# specify the length of the window
windows <- REHdynamics::createwindows(2000, tau)

# fit to the REM model
model_fixwin_1cp <- REHdynamics::MWrem(windows, edgelist = reh_1cp, 
                                       stats = stat.1cp,
                                       actors = covar$id, directed = TRUE, 
                                       method = "MLE", model = "tie", ncores = 2)
```

2. Step 2: Extract the parameters by windows and plot them out
```{r}
# extract the parameters
fixmw_ine_1cp_param <- 1
for (i in 1:length(model_fixwin_1cp)) {
  fixmw_ine_1cp_param[i] <- model_fixwin_1cp[[i]][["coefficients"]][["inertia"]]
}
plot(fixmw_ine_1cp_param, type = "lm") # plot the movement of parameter
```

*Test CPs of the Fixed MW parameters*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_fixmw_ine_1cp_param <- onlineCPD(fixmw_ine_1cp_param, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_fixmw_ine_1cp_param[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_fixmw_ine_1cp_param)
```

2. PELT: Exact CPs Detection Method
```{r}
PELT_fixmw_ine_1cp_param <- cpt.var(fixmw_ine_1cp_param, method="PELT")
summary(PELT_fixmw_ine_1cp_param)

# plot the location of CPs
plot(fixmw_ine_1cp_param, type="l", col = "red")
abline(v=PELT_fixmw_ine_1cp_param@cpts[], col="black")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_fixmw_ine_1cp_param <- cpt.meanvar(fixmw_ine_1cp_param, method = "BinSeg")
cpts(BS_fixmw_ine_1cp_param)

# plot the location of CPs
plot(fixmw_ine_1cp_param)
abline(v=BS_fixmw_ine_1cp_param@cpts[], col="red")
```

4. Wild BS
```{r}
WBS_fixmw_ine_1cp_param <- wbs(fixmw_ine_1cp_param)
changepoints(WBS_fixmw_ine_1cp_param)
plot(WBS_fixmw_ine_1cp_param)
```

**REH with many CPs**

```{r}
set.seed(9252568)
# REH with only inertia statistics
#formula <- ~ 1 + remstats::inertia(scaling = "std")

# set up the covariates
#covar <- data.frame(id = 1:15, time = 0, z = rnorm(n = 15))

# set up the value of parameters
param.scp <- list(
  "baseline" = -8.8,
  
  "inertia" = function(t) {
    # set the location of CP
    if(t < 16750) { #2574
      0.18
      } else 
      
      if(t < 38200) { #5365
        0.07
        } else 
        
        if(t < 53900) { #7519
          0.13
          } else {0.08}
  }
)

# create REH with 1 CP
reh_scp <- list()

rep <- 1 # replication times (number of datasets you wanna get)

for (i in 1: rep){
  reh_scp[[i]] <- generate(formula = formula, param = param.scp, M = 10000, covar = covar)
  print(i)
}
```

*Plot the Statistics out*
```{r}
# compute the statistics
out.scp <- remstats(tie_effects = formula, edgelist = reh_scp) # also will be used for fitting REM
stat.scp <- out.scp[["statistics"]] # extract the statistics from the list

# extract the statistics of inertia
ine_scp <- stat.scp[,,2]

# aggregate the statistics of each time point
ine_scp.agg.max <- rowMaxs(ine_scp)
plot(ine_scp.agg.max, type = "lm")

ine_scp.agg.mean <- rowMeans(ine_scp)
plot(ine_scp.agg.mean, type = "lm")
```

*Test CPs of the aggregated statistics (mean and max)*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_ine_scp.agg.mean <- onlineCPD(ine_scp.agg.mean, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ine_scp.agg.mean[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_scp.agg.mean)

BOCD_ine_scp.agg.max <- onlineCPD(ine_scp.agg.max, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ine_scp.agg.max[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_scp.agg.max)
```

2. PELT: Exact CPs Detection Method

- Mean
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_scp.agg.mean <- cpt.var(ine_scp.agg.mean, method="PELT")
summary(PELT_ine_scp.agg.mean)

# plot the location of detected CPs
plot(ine_scp.agg.mean, type="point", col = "black")
abline(v=PELT_ine_scp.agg.mean@cpts[], col="red")
```

- Max
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_scp.agg.max <- cpt.var(ine_scp.agg.max, method="PELT")
summary(PELT_ine_scp.agg.max)

# plot the location of detected CPs
plot(ine_scp.agg.max, type="point", col = "black")
abline(v=PELT_ine_scp.agg.max@cpts[], col="red")
```

3. BS: approximate CPs Detection Method

- Mean
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_scp.agg.mean <- cpt.meanvar(ine_scp.agg.mean, method = "BinSeg")
cpts(BS_ine_scp.agg.mean)

# plot the location of CPs
plot(ine_scp.agg.mean)
abline(v=BS_ine_scp.agg.mean@cpts[], col="red")
```

- Max
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_scp.agg.max <- cpt.meanvar(ine_scp.agg.max, method = "BinSeg")
cpts(BS_ine_scp.agg.max)

# plot the location of CPs
plot(ine_scp.agg.max)
abline(v=BS_ine_scp.agg.max@cpts[], col="red")
```

4. Wild BS

- Mean
```{r}
WBS_ine_scp.agg.mean <- wbs(ine_scp.agg.mean)
changepoints(WBS_ine_scp.agg.mean)
plot(WBS_ine_scp.agg.mean)
```

- Max
```{r}
WBS_ine_scp.agg.max <- wbs(ine_scp.agg.max)
changepoints(WBS_ine_scp.agg.max)
plot(WBS_ine_scp.agg.max)
```

*Test CPs of the aggregated statistics (top 5% of maximum statistics by timepoints)*

```{r}
# compute the mean of top 5% of maximum statistics by timepoints
top_ine_scp <- max_mean_time(ine_scp, percent = 0.05)$means_max.values_each_timepoint
plot(top_ine_scp) # plot it out
```

1. BOCD: Exact CPs Detection Method
```{r}
# test the CPs
BOCD_ine_scp.agg.top <- onlineCPD(top_ine_scp, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ine_scp.agg.top[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ine_scp.agg.top)
```

2. PELT: Exact CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
PELT_ine_scp.agg.top <- cpt.var(top_ine_scp, method="PELT")
summary(PELT_ine_scp.agg.top)

# plot the location of detected CPs
plot(top_ine_scp, type="l", col = "black")
abline(v=PELT_ine_scp.agg.top@cpts[], col="red")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ine_scp.agg.top <- cpt.meanvar(top_ine_scp, method = "BinSeg")
cpts(BS_ine_scp.agg.top)

# plot the location of CPs
plot(top_ine_scp)
abline(v=BS_ine_scp.agg.top@cpts[], col="red")
```

4. Wild BS
```{r}
WBS_ine_scp.agg.top <- wbs(top_ine_scp)
changepoints(WBS_ine_scp.agg.top)
plot(WBS_ine_scp.agg.top)
```

*Fit the Data-Driven MW REM on the REH with 1 CP*

```{r}
# extract the synthetic data with 1 CP (data frmae)
reh_scp <- reh_scp[[1]]
```

1. Step 1: compute the optimal lengths of the windows
```{r}
# obtain data-driven window widths
ddwin_scp <- ddwindows(edgelist = reh_scp, tie_effects = formula, mintime = 2000, 
		covar = covar)
```

2. Step 2: fit the REM by windows
```{r}
#  fits a moving window relational event model
model_ddwin_scp <- MWrem(windows = ddwin_scp$windows, edgelist = reh_scp, 
		stats = stat.scp, actors = covar$id, directed = TRUE)
```

3. Step 3: extract the parameters by windows and plot them out
```{r}
# extract the parameters
ddmw_ine_scp_param <- 1
for (i in 1:length(model_ddwin_scp)) {
  ddmw_ine_scp_param[i] <- model_ddwin_scp[[i]][["coefficients"]][["inertia"]]
}
plot(ddmw_ine_scp_param, type = "lm") # plot the movement of parameter
```

*Test CPs of the DDMW parameters*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_ddmw_ine_scp_param <- onlineCPD(ddmw_ine_scp_param, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_ddmw_ine_scp_param[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_ddmw_ine_scp_param)
```

2. PELT: Exact CPs Detection Method
```{r}
PELT_ddmw_ine_scp_param <- cpt.var(ddmw_ine_scp_param, method="PELT")
summary(PELT_ddmw_ine_scp_param)

# plot the location of CPs
plot(ddmw_ine_scp_param, type="l", col = "red")
abline(v=PELT_ddmw_ine_scp_param@cpts[], col="black")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_ddmw_ine_scp_param <- cpt.meanvar(ddmw_ine_scp_param, method = "BinSeg")
cpts(BS_ddmw_ine_scp_param)

# plot the location of CPs
plot(ddmw_ine_scp_param)
abline(v=BS_ddmw_ine_scp_param@cpts[], col="black")
```

4. Wild BS
```{r}
WBS_ddmw_ine_scp_param <- wbs(ddmw_ine_scp_param)
changepoints(WBS_ddmw_ine_scp_param)
plot(WBS_ddmw_ine_scp_param)
```


*Fit the Fixed MW REM on the REH with One CP*

1. Step 1: Decide the length of the window, and fit it into REM
```{r}
# maximum time point of the REH
tau <- max(reh_scp$time)

# specify the length of the window
windows <- REHdynamics::createwindows(2000, tau)

# fit to the REM model
model_fixwin_scp <- REHdynamics::MWrem(windows, edgelist = reh_scp, 
                                       stats = stat.scp,
                                       actors = covar$id, directed = TRUE, 
                                       method = "MLE", model = "tie", ncores = 2)
```

2. Step 2: Extract the parameters by windows and plot them out
```{r}
# extract the parameters
fixmw_ine_scp_param <- 1
for (i in 1:length(model_fixwin_scp)) {
  fixmw_ine_scp_param[i] <- model_fixwin_scp[[i]][["coefficients"]][["inertia"]]
}
plot(fixmw_ine_scp_param, type = "lm") # plot the movement of parameter
```

*Test CPs of the Fixed MW parameters*

1. BOCD: Exact CPs Detection Method
```{r}
BOCD_fixmw_ine_scp_param <- onlineCPD(fixmw_ine_scp_param, getR = T, optionalOutputs = T, truncRlim = 10^-4)
BOCD_fixmw_ine_scp_param[["changepoint_lists"]][["maxCPs"]][[1]]
plot(BOCD_fixmw_ine_scp_param)
```

2. PELT: Exact CPs Detection Method
```{r}
PELT_fixmw_ine_scp_param <- cpt.var(fixmw_ine_scp_param, method="PELT")
summary(PELT_fixmw_ine_scp_param)

# plot the location of CPs
plot(fixmw_ine_scp_param, type="l", col = "red")
abline(v=PELT_fixmw_ine_scp_param@cpts[], col="black")
```

3. BS: approximate CPs Detection Method
```{r}
# cpt.meanvar -> find changes in both mean and variance for data
BS_fixmw_ine_scp_param <- cpt.meanvar(fixmw_ine_scp_param, method = "BinSeg")
cpts(BS_fixmw_ine_scp_param)

# plot the location of CPs
plot(fixmw_ine_scp_param)
abline(v=BS_fixmw_ine_scp_param@cpts[], col="red")
```

4. Wild BS
```{r}
WBS_fixmw_ine_scp_param <- wbs(fixmw_ine_scp_param)
changepoints(WBS_fixmw_ine_scp_param)
plot(WBS_fixmw_ine_scp_param)
```


1. We can probably use confusion matrix to compare which method has the best performance

2. Increase the statistics, e.g., gender, sender effects...,etc.

3. only used happened events statistics for detecting
