---
title: "Untitled"
author: "Hsuan Lee"
output: pdf_document
---

```{r}
library(remstats) # the formula for REH
library(relevent) # fit REH to REM
library(REHdynamics) # fit the moving window REM
library(ocp) # package for BOCD
library(changepoint) # package for PELT, BS
set.seed(9252568)
```

```{r}
# Load data using load():
#load("RealLife_Data/Merged_ALL_parts_Apollo.rdata")
Apollo13 <- read.csv("RealLife_Data/Apollo13.csv", sep =';')
```































```{r}
Apollo.13 <- readRDS(file = "RealLife_Data/PartOfApollo_13.RDS")

colnames(Apollo.13) <- c("time", "actor1", "actor2")

Apollo.13$actor1[Apollo.13$actor1 == 17] <- 14
Apollo.13$actor1[Apollo.13$actor1 == 18] <- 15
Apollo.13$actor1[Apollo.13$actor1 == 19] <- 16

Apollo.13$actor2[Apollo.13$actor2 == 17] <- 14
Apollo.13$actor2[Apollo.13$actor2 == 18] <- 15
Apollo.13$actor2[Apollo.13$actor2 == 19] <- 16

sort(unique(Apollo.13$actor1))
sort(unique(Apollo.13$actor2))
```

```{r}
formula <- ~ 1 + 
  remstats::inertia(scaling = "std") + # Endogenous statistics
  remstats::outdegreeSender(scaling='std') # Endogenous statistics
```

```{r}
# set up the covariates
covar <- data.frame(id = 1:16, time = 0)
```

```{r}
# compute the statistics
out <- remstats(tie_effects = formula, edgelist = Apollo.13, actors = 16)

# extract the statistics from the list
stat <- out[["statistics"]]
```

```{r}
# maximum time point of each iteration of REH
tau <- max(Apollo.13$time)

# specify the length of the window
windows <- REHdynamics::createwindows(1000, tau, overlap = 2/3)

# fit to the REM model
model_fixwin <- REHdynamics::MWrem(windows, edgelist = Apollo.13, 
                                   stats = stat,
                                   actors = covar$id, directed = TRUE, 
                                   method = "MLE", model = "tie", ncores = 2)
dim(Apollo.13)
dim(stat)
is.na(Apollo.13)
```


```{r}
# extract the parameters
fixmw_ine_param <- 1
for (i in 34:length(model_fixwin)) {
  fixmw_ine_param[i] <- model_fixwin[[i]][["coefficients"]][["inertia"]]
}
plot(fixmw_ine_param, type = "point") # plot the movement of parameter
```

```{r}
# extract the parameters
fixmw_out_param <- 1
for (i in 34:length(model_fixwin)) {
  fixmw_out_param[i] <- model_fixwin[[i]][["coefficients"]][["outdegreeSender"]]
}
plot(fixmw_out_param, type = "point") # plot the movement of parameter
```

```{r}
# changepoint 42424.8 second

PELT_fixmw_ine <- cpt.meanvar(fixmw_ine_param[34:148], method="PELT")

PELT_fixmw_ine@cpts[-length(PELT_fixmw_ine@cpts)] + 34

```

```{r}
PELT_fixmw_out <- cpt.meanvar(fixmw_out_param[34:148], method="PELT")

PELT_fixmw_out@cpts[-length(PELT_fixmw_out@cpts)] + 34
```



```{r}
BOCD_fixmw_ine_param <- onlineCPD(fixmw_ine_param[34:148], 
                                            getR = T, 
                                            optionalOutputs = T, 
                                            truncRlim = 10^-4)

locat_BOCD_ine <- BOCD_fixmw_ine_param[["changepoint_lists"]][["maxCPs"]][[1]] +34
# remove the first value of the vector, as BOCPD function indicates the first window as CP all the time
(locat_BOCD_ine <- locat_BOCD_ine[-1])

plot(BOCD_fixmw_ine_param)
```

```{r}
BOCD_fixmw_out_param <- onlineCPD(fixmw_out_param[34:148], 
                                            getR = T, 
                                            optionalOutputs = T, 
                                            truncRlim = 10^-4)

locat_BOCD_out <- BOCD_fixmw_out_param[["changepoint_lists"]][["maxCPs"]][[1]] +34
# remove the first value of the vector, as BOCPD function indicates the first window as CP all the time
(locat_BOCD_out <- locat_BOCD_out[-1])

plot(BOCD_fixmw_out_param)
```















1. Step 1: compute the optimal lengths of the windows
```{r}
# obtain data-driven window widths
ddwin <- ddwindows(edgelist = Apollo.13, tie_effects = formula, mintime = 1000, 
		covar = covar)
```

2. Step 2: fit the REM by windows
```{r}
#  fits a moving window relational event model
model_ddwin <- MWrem(windows = ddwin$windows, edgelist = Apollo.13, 
		stats = stat, actors = covar$id, directed = TRUE)
```

3. Step 3: extract the parameters by windows and plot them out
```{r}
# extract the parameters
ddmw_send_param <- 1
for (i in 34:length(model_ddwin)) {
  ddmw_send_param[i] <- model_ddwin[[i]][["coefficients"]][["inertia"]]
}
plot(ddmw_send_param, type = "lm") # plot the movement of parameter
```

```{r}
# extract the parameters
ddmw_diff_1cp_param_diff.all <- 1
for (i in 1:length(model_ddwin_1cp_diff.all)) {
  ddmw_diff_1cp_param_diff.all[i] <- model_ddwin_1cp_diff.all[[i]][["coefficients"]][["difference.z"]]
}
plot(ddmw_diff_1cp_param_diff.all, type = "lm") # plot the movement of parameter
```

```{r}
# extract the parameters
ddmw_ine_1cp_param_diff.all <- 1
for (i in 1:length(model_ddwin_1cp_diff.all)) {
  ddmw_ine_1cp_param_diff.all[i] <- model_ddwin_1cp_diff.all[[i]][["coefficients"]][["inertia"]]
}
plot(ddmw_ine_1cp_param_diff.all, type = "lm") # plot the movement of parameter
```

```{r}
# extract the parameters
ddmw_reci_1cp_param_diff.all <- 1
for (i in 1:length(model_ddwin_1cp_diff.all)) {
  ddmw_reci_1cp_param_diff.all[i] <- model_ddwin_1cp_diff.all[[i]][["coefficients"]][["reciprocity"]]
}
plot(ddmw_reci_1cp_param_diff.all, type = "lm") # plot the movement of parameter
```
```








