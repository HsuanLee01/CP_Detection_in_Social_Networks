---
title: "Comparison of CPDs"
author: "Hsuan Lee"
output: pdf_document
---
```{r}
# install.packages('caret')
#library(caret) # for confusion matrix
```

# Create a function for Confusion Matrix

**Confusion Matrix Function for the data with changepoints**
```{r}
conf_matrix <- function(pred_CPs, # e.g. locat_BOCD_1cp_out_same.all
                        true_CPs, # a matrix, no. of col = no. of cp; row = acceptable detected cp
                        window_parameters # the window given parameters, e.g. fixmw_send_1cp_param
){
  
  confusion_assign <- vector(mode='list', length = length(window_parameters))
  leveling <- list()
  confusionmatrix <- list()
  
  for (i in 1:length(pred_CPs)) {
    
    if (ncol(true_CPs) > 0) {
      for (detect_cp in 0:length(pred_CPs[[i]])) {
        
        if (sum(confusion_assign[[i]] == "TP") < ncol(true_CPs)) { # add restriction here
          confusion_assign[[i]][detect_cp] <- 
            if (length(pred_CPs[[i]][detect_cp]) > 0 && pred_CPs[[i]][detect_cp] %in% true_CPs) {
              "TP"
            } else {
              "NA"
            }
        } else {
          confusion_assign[[i]][detect_cp] <- "FP"
        }
        
      }
      
      FN <- list()
      FN[[i]] <- ncol(true_CPs) - sum(confusion_assign[[i]] == "TP")
      
      confusion_assign[[i]] <- c(confusion_assign[[i]], rep("FN", FN[[i]]))
      
      #confusion_assign[[i]] <- c(confusion_assign[[i]], 
      #                           rep("TN", 
      #                               length(window_parameters[[i]]) - length(confusion_assign[[i]])))
      
      level <- c("TP", "FP", "FN", "TN")
      leveling[[i]] <- factor(confusion_assign[[i]], level)
      confusionmatrix[[i]] <- table(leveling[[i]])
    } else { 
      # if no true_CPs are present
      confusion_assign[[i]] <- rep("FP", length(pred_CPs[[i]]))
      
      #confusion_assign[[i]] <- c(confusion_assign[[i]], 
      #                           rep("TN", 
      #                               length(window_parameters[[i]]) - length(confusion_assign[[i]])))
      
      level <- c("TP", "FP", "FN", "TN")
      leveling[[i]] <- factor(confusion_assign[[i]], level)
      confusionmatrix[[i]] <- table(leveling[[i]])
    }
    
  }
  
  # combine all the confusion assignments from each dataset together
  total_confusion <- unlist(confusion_assign)
  total_leveling <- factor(total_confusion, level)
  total_confusionmatrix <- table(total_leveling)
  
  # True Positive Rate 
  # In all positive observations, what is the probability that the model correctly predicts the true positive
  TPR <- total_confusionmatrix[["TP"]] / 
    (total_confusionmatrix[["TP"]] + total_confusionmatrix[["FN"]])
  
  # Positive Predictive Value
  # The CPD predicts a CP, what is the actual prob. it is a CP.
  PPV <- total_confusionmatrix[["TP"]] /
    (total_confusionmatrix[["TP"]] + total_confusionmatrix[["FP"]])
  
  return(list(confusionmatrix = confusionmatrix,
              total_confusionmatrix = total_confusionmatrix,
              TPR = TPR,
              PPV = PPV))
}
```

```{r}
true_cp <- matrix(data = c(58, 59, 60, 61, 62, 63, 57, 56, 55, 54, 53), ncol = 1)
true_cp <- matrix(, nrow = 1, ncol = 0)
a <- conf_matrix(pred_CPs = locat_BOCD_ncp_ine, true_CPs = true_cp, window_parameters = fixmw_ine_ncp_param)
```





# Create a function for MSE
```{r}
MSE_CPD <- function(pred_CPs,# e.g. locat_BOCD_1cp_out_same.all
                    true_CPs, # a vector
                    range # the acceptable range of detexted CPs
                    ){
  
  initial_MSE <- list()
  sum_se <- list()
  
  for (i in 1:length(pred_CPs)) {
    
    if(length(pred_CPs[[i]]) > 0){
      
      # Define dimensions of detected_MSE matrix
      detected_MSE <- matrix(0, nrow = length(pred_CPs[[i]]), ncol = length(true_CPs))
      
      for (cp_det in 1:length(pred_CPs[[i]])) {
        
        for (cp_true in 1: length(true_CPs)) {
          detected_MSE[cp_det,cp_true] <- (true_CPs[cp_true] - pred_CPs[[i]][cp_det])^2
        }
      }
      
      # Find minimum MSE for each true CP
      initial_MSE[[i]] <- apply(detected_MSE, 2, function(x) {
        
        min_val <- min(x)
        
        if (min_val <= range^2) {
          min_val
          } else {
            "NA"
            }
        })
    }
    
    # sum the square error of each CP
    sum_se[[i]] <- sum(initial_MSE[[i]], na.rm = TRUE)
    
  }
  
  return(list(initial_MSE,
              sum_se))
}









MSE_CPD <- function(pred_CPs, true_CPs, range){
  initial_MSE <- lapply(seq_along(pred_CPs), function(x) list())
  sum_se <- lapply(seq_along(pred_CPs), function(x) list())
  
  for (i in 1:length(pred_CPs)) {
    
    if(length(pred_CPs[[i]]) > 0){
      
      # Define dimensions of detected_MSE matrix
      detected_MSE <- matrix(0, nrow = length(pred_CPs[[i]]), ncol = length(true_CPs))
      
      for (cp_det in 1:length(pred_CPs[[i]])) {
        
        for (cp_true in 1: length(true_CPs)) {
          detected_MSE[cp_det,cp_true] <- (true_CPs[cp_true] - pred_CPs[[i]][cp_det])^2
        }
      }
      
      # Find minimum MSE for each true CP
      initial_MSE[[i]] <- apply(detected_MSE, 2, function(x) {
        
        min_val <- min(x)
        
        if (min_val <= range^2) {
          min_val
        } else {
          NA
        }
      })
    }
    
    # extract values from initial_MSE and sum the square error of each CP
    sum_se[[i]] <- sum(unlist(initial_MSE[[i]]), na.rm = T)
    
  }
  
  return(list(initial_MSE, sum_se))
}







c <- MSE_CPD(pred_CPs = locat_BOCD_1cp_ine, true_CPs = 57, range = 5)

c <- MSE_CPD(pred_CPs = locat_BOCD_2cp_ine, true_CPs = c(24, 77), range = 5)

```
















# Create a function for MSD
```{r}
MSD_CPD <- function(pred_CPs, actu_CPs){
  
  single_MSD <- 0 # create an blank vector for storing
  
  for (CP in 1:length(pred_CPs)) {
    # MSD of each CP
    single_MSD[CP] <- pred_CPs[CP] - actu_CPs[CP]
    }
  
  # sum the MSD from each CP
  sum_MSD <- sum(single_MSD)
  
  # MSD
  MSD <- sum_MSD / length(pred_CPs)
  
  return(MSD)
}
```
































