---
title: "Comparison of CPDs"
author: "Hsuan Lee"
output: pdf_document
---
```{r}
# install.packages('caret')
#library(caret) # for confusion matrix
```

# Create a function for Confusion Matrix

**Confusion Matrix for the effects with CPs**
```{r}
conf_matrix_cp <- function(pred_CPs, # e.g. locat_BOCD_1cp_out_same.all
                        true_CPs, # a matrix, no. of col = no. of cp; row = acceptable detected cp
                        window_parameters # the window given parameters, e.g. fixmw_send_1cp_param
){
  
  confusion_assign <- vector(mode='list', length = length(window_parameters))
  leveling <- list()
  confusionmatrix <- list()
  
  for (i in 1:length(pred_CPs)) {
    
    if (ncol(true_CPs) > 0) {
      for (detect_cp in 0:length(pred_CPs[[i]])) {
        
        if (sum(confusion_assign[[i]] == "TP") < ncol(true_CPs)) { # add restriction here
          confusion_assign[[i]][detect_cp] <- 
            if (length(pred_CPs[[i]][detect_cp]) > 0 && pred_CPs[[i]][detect_cp] %in% true_CPs) {
              "TP"
            } else {
              "NA"
            }
        } else {
          confusion_assign[[i]][detect_cp] <- "FP"
        }
        
      }
      
      FN <- list()
      FN[[i]] <- ncol(true_CPs) - sum(confusion_assign[[i]] == "TP")
      
      confusion_assign[[i]] <- c(confusion_assign[[i]], rep("FN", FN[[i]]))
      
      #confusion_assign[[i]] <- c(confusion_assign[[i]], 
      #                           rep("TN", 
      #                               length(window_parameters[[i]]) - length(confusion_assign[[i]])))
      
      level <- c("TP", "FP", "FN", "TN")
      leveling[[i]] <- factor(confusion_assign[[i]], level)
      confusionmatrix[[i]] <- table(leveling[[i]])
    } else { 
      # if no true_CPs are present
      confusion_assign[[i]] <- rep("FP", length(pred_CPs[[i]]))
      
      #confusion_assign[[i]] <- c(confusion_assign[[i]], 
      #                           rep("TN", 
      #                               length(window_parameters[[i]]) - length(confusion_assign[[i]])))
      
      level <- c("TP", "FP", "FN", "TN")
      leveling[[i]] <- factor(confusion_assign[[i]], level)
      confusionmatrix[[i]] <- table(leveling[[i]])
    }
    
  }
  
  # combine all the confusion assignments from each dataset together
  total_confusion <- unlist(confusion_assign)
  total_leveling <- factor(total_confusion, level)
  total_confusionmatrix <- table(total_leveling)
  
  # True Positive Rate 
  # In all positive observations, what is the probability that the model correctly predicts the true positive
  # The probability that a CPD correctly detect CPs
  TPR <- total_confusionmatrix[["TP"]] / 
    (total_confusionmatrix[["TP"]] + total_confusionmatrix[["FN"]])
  
  # Positive Predictive Value
  # The CPD predicts a CP, what is the actual prob. it is a CP.
  PPV <- total_confusionmatrix[["TP"]] /
    (total_confusionmatrix[["TP"]] + total_confusionmatrix[["FP"]])
  
  # False Positive Rate
  # In all positive observations, what is the probability that the model wrongly predicts the positive
  # The probability that a CPD detect CPs when there is no CP
  #FPR <- total_confusionmatrix[["FP"]] / 
  #  (total_confusionmatrix[["FP"]] + total_confusionmatrix[["TN"]])
  
  # Negative Predictive Value
  # The CPD predicts a window as not a CP, what is the actual prob. it is not a CP.
  #NPV <- total_confusionmatrix[["TN"]] / 
  #  (total_confusionmatrix[["TN"]] + total_confusionmatrix[["FN"]])
  
  return(list(confusionmatrix = confusionmatrix,
              total_confusionmatrix = total_confusionmatrix,
              TPR = TPR,
              PPV = PPV
              #FPR = FPR,
              #NPV = NPV
              ))
}
```

**Confusion Matrix for the effects without CPs**
```{r}
conf_matrix_ncp <- function(pred_CPs, # e.g. locat_BOCD_1cp_out_same.all
                        true_CPs, # a matrix, no. of col = no. of cp; row = acceptable detected cp
                        window_parameters # the window given parameters, e.g. fixmw_send_1cp_param
){
  
  confusion_assign <- vector(mode='list', length = length(window_parameters))
  leveling <- list()
  confusionmatrix <- list()
  
  for (i in 1:length(pred_CPs)) {
    
    if (ncol(true_CPs) > 0) {
      for (detect_cp in 0:length(pred_CPs[[i]])) {
        
        if (sum(confusion_assign[[i]] == "TP") < ncol(true_CPs)) { # add restriction here
          confusion_assign[[i]][detect_cp] <- 
            if (length(pred_CPs[[i]][detect_cp]) > 0 && pred_CPs[[i]][detect_cp] %in% true_CPs) {
              "TP"
            } else {
              "NA"
            }
        } else {
          confusion_assign[[i]][detect_cp] <- "FP"
        }
        
      }
      
      FN <- list()
      FN[[i]] <- ncol(true_CPs) - sum(confusion_assign[[i]] == "TP")
      
      confusion_assign[[i]] <- c(confusion_assign[[i]], rep("FN", FN[[i]]))
      
      #confusion_assign[[i]] <- c(confusion_assign[[i]], 
      #                           rep("TN", 
      #                               length(window_parameters[[i]]) - length(confusion_assign[[i]])))
      
      level <- c("TP", "FP", "FN", "TN")
      leveling[[i]] <- factor(confusion_assign[[i]], level)
      confusionmatrix[[i]] <- table(leveling[[i]])
    } else { 
      # if no true_CPs are present
      confusion_assign[[i]] <- rep("FP", length(pred_CPs[[i]]))
      
      confusion_assign[[i]] <- c(confusion_assign[[i]], 
                                 rep("TN", 
                                     length(window_parameters[[i]]) - length(confusion_assign[[i]])))
      
      level <- c("TP", "FP", "FN", "TN")
      leveling[[i]] <- factor(confusion_assign[[i]], level)
      confusionmatrix[[i]] <- table(leveling[[i]])
    }
    
  }
  
  # combine all the confusion assignments from each dataset together
  total_confusion <- unlist(confusion_assign)
  total_leveling <- factor(total_confusion, level)
  total_confusionmatrix <- table(total_leveling)
  
  # True Positive Rate 
  # In all positive observations, what is the probability that the model correctly predicts the true positive
  # The probability that a CPD correctly detect CPs
  #TPR <- total_confusionmatrix[["TP"]] / 
  #  (total_confusionmatrix[["TP"]] + total_confusionmatrix[["FN"]])
  
  # Positive Predictive Value
  # The CPD predicts a CP, what is the actual prob. it is a CP.
  #PPV <- total_confusionmatrix[["TP"]] /
  #  (total_confusionmatrix[["TP"]] + total_confusionmatrix[["FP"]])
  
  # False Positive Rate
  # In all positive observations, what is the probability that the model wrongly predicts the positive
  # The probability that a CPD detect CPs when there is no CP
  FPR <- total_confusionmatrix[["FP"]] / 
    (total_confusionmatrix[["FP"]] + total_confusionmatrix[["TN"]])
  
  # Negative Predictive Value
  # The CPD predicts a window as not a CP, what is the actual prob. it is not a CP.
  NPV <- total_confusionmatrix[["TN"]] / 
    (total_confusionmatrix[["TN"]] + total_confusionmatrix[["FN"]])
  
  return(list(confusionmatrix = confusionmatrix,
              total_confusionmatrix = total_confusionmatrix,
              #TPR = TPR,
              #PPV = PPV,
              FPR = FPR,
              NPV = NPV
              ))
}
```

# Create a function for MSE

```{r}
MSE_CPD <- function(pred_CPs, # detected CPs, e.g. locat_BOCD_1cp_out_same.all
                    true_CPs, # a vector, the location of true CPs
                    range # the range that the detected CP inside that range with true CP can still recognized as TP
){
  
  # create a blank list for square error with the same length as number of datasets
  initial_SE <- lapply(seq_along(pred_CPs), function(x) list())
  
  # create a blank list to store mean square error of each dataset
  MSE <- lapply(seq_along(pred_CPs), function(x) list())
  
  # for each dataset
  for (i in 1:length(pred_CPs)) {
    
    if(length(pred_CPs[[i]]) > 0){ # if the length of detected CPs larger than 0
      
      # Define dimensions of detected_SE matrix: row = number of detected CPs, col = number of true CPs
      detected_SE <- matrix(0, nrow = length(pred_CPs[[i]]), ncol = length(true_CPs))
      
      # for row, i.e., number of detected CPs
      for (cp_det in 1:length(pred_CPs[[i]])) {
        
        # for column, i.e., number of true CPs
        for (cp_true in 1: length(true_CPs)) {
          
          # store the square error of all the detected CPs with all the true CP into the matrix
          detected_SE[cp_det,cp_true] <- (true_CPs[cp_true] - pred_CPs[[i]][cp_det])^2
        }
      }
      
      # Find minimum SE for each true CP, as only the minimum one is the real detected CP for that true CP
      initial_SE[[i]] <- apply(detected_SE, 2, function(x) {
        
        min_val <- min(x)
        
        # if min_val equals 1, change it to 0, as one true CPs can be in three windows
        #if (min_val == 1) {
        #  min_val <- 0
        #}
        
        # the range that the detected CP inside that range with true CP can still recognized as TP
        if (min_val <= range^2) {
          min_val
        } else {
          NA # if the detected CP is not inside the range, we assign it a NA (FP)
        }
      })
      
      # Remove NAs from initial_SE, so that we can obtain the real length of each set
      initial_SE[[i]] <- na.omit(initial_SE[[i]])
    }
    
    # extract values from initial_SE and sum the square error of each CP
    MSE[[i]] <- sum(unlist(initial_SE[[i]]), na.rm = T) / length(initial_SE[[i]])
    
  }
  # the average MSE of all datasets
  total_MSE <- mean(unlist(MSE), na.rm = T)
  
  return(list(MSE = MSE, 
              Averade_MSE = total_MSE))
}
```

# Create a function for MSD

```{r}
MSD_CPD <- function(pred_CPs, # detected CPs, e.g. locat_BOCD_1cp_out_same.all
                    true_CPs, # a vector, the location of true CPs
                    range # the range that the detected CP inside that range with true CP can still recognized as TP
) {
  
  # create a blank list for sign difference with the same length as number of datasets
  initial_SD <- lapply(seq_along(pred_CPs), function(x) list())
  
  # create a blank list to store mean sign difference of each dataset
  MSD <- lapply(seq_along(pred_CPs), function(x) list())
  
  # for each dataset
  for (i in 1:length(pred_CPs)) {
    
    if(length(pred_CPs[[i]]) > 0){ # if the length of detected CPs larger than 0
      
      # Define dimensions of detected_SD matrix: row = number of detected CPs, col = number of true CPs
      detected_SD <- matrix(0, nrow = length(pred_CPs[[i]]), ncol = length(true_CPs))
      
      # for row, i.e., number of detected CPs
      for (cp_det in 1:length(pred_CPs[[i]])) {
        
        # for column, i.e., number of true CPs
        for (cp_true in 1:length(true_CPs)) {
          
          # store the sign difference of all the detected CPs with all the true CP into the matrix
          detected_SD[cp_det,cp_true] <- pred_CPs[[i]][cp_det] - true_CPs[cp_true]
        }
      }
      
      # Find minimum SD for each true CP, as only the minimum one is the real detected CP for that true CP
      initial_SD[[i]] <- apply(detected_SD, 2, function(x) {
        
        # calculate the minimum absolute distance and multiply it by the sign of the corresponding element
        # in order to maintain the original sign (positive/negative) of the distance
        # sign(x) returns the sign of a real number x, which is either -1, 0, or 1, 
        # depending on whether x is negative, zero, or positive, respectively.
        # which.min(abs(x)) is used to find the index of the element with the smallest absolute value in the vector x
        min_val <- sign(x[which.min(abs(x))]) * min(abs(x))
        
        # if the minimum absolute distance is 1, change it to 0, as one true CP can be in three windows
        #if (abs(min_val) == 1) {
        #  min_val <- 0
        #}
        
        # the range that the detected CP inside that range with true CP can still recognized as TP
        if (abs(min_val) <= range) {
          min_val
        } else {
          NA # if the detected CP is not inside the range, we assign it a NA (FP)
        }
      })
      
      # Remove NAs from initial_SD, so that we can obtain the real length of each set
      initial_SD[[i]] <- na.omit(initial_SD[[i]])
    }
    
    # extract values from initial_SD and sum the SD of each CP
    MSD[[i]] <- sum(unlist(initial_SD[[i]]), na.rm = TRUE) / length(initial_SD[[i]])
    
  }
  # the average MSD of all datasets
  total_MSD <- mean(unlist(MSD), na.rm = TRUE)
  
  return(list(MSD = MSD, 
              Average_MSD = total_MSD))
}
```

Difference between `min()` and `which.min()`

Suppose we have the vector x <- c(5, 2, 7, 1, 9). The min() function will return the smallest value in the vector, which is 1.

Now, suppose we also want to know the index of the smallest value in the vector. We can use the which.min() function for that. In this case, which.min(x) will return the index 4, since 1 is the smallest value and it occurs in the 4th position in the vector.

-----------------------

# Start Comparison

## Confusion Matrix

**The REH without CPs**

Assign the true CP for no changepoint
```{r}
true_ncp <- matrix(, nrow = 1, ncol = 0)
```

### BOCPD

- Sender Effect
```{r}
(Conf_Mat_BOCD_send_ncp <- conf_matrix_ncp(pred_CPs = locat_BOCD_ncp_send, true_CPs = true_ncp, 
                        window_parameters = fixmw_send_ncp_param))
```

- Diference
```{r}
(Conf_Mat_BOCD_diff_ncp <- conf_matrix_ncp(pred_CPs = locat_BOCD_ncp_diff, true_CPs = true_ncp, 
                        window_parameters = fixmw_diff_ncp_param))
```

- Inertia
```{r}
(Conf_Mat_BOCD_ine_ncp <- conf_matrix_ncp(pred_CPs = locat_BOCD_ncp_ine, true_CPs = true_ncp, 
                        window_parameters = fixmw_ine_ncp_param))
```

- Outdegree Sender
```{r}
(Conf_Mat_BOCD_out_ncp <- conf_matrix_ncp(pred_CPs = locat_BOCD_ncp_out, true_CPs = true_ncp, 
                        window_parameters = fixmw_out_ncp_param))
```

### PELT

- Sender Effect
```{r}
(Conf_Mat_PELT_send_ncp <- conf_matrix_ncp(pred_CPs = locat_PELT_ncp_send, true_CPs = true_ncp, 
                        window_parameters = fixmw_send_ncp_param))
```

- Diference
```{r}
(Conf_Mat_PELT_diff_ncp <- conf_matrix_ncp(pred_CPs = locat_PELT_ncp_diff, true_CPs = true_ncp, 
                        window_parameters = fixmw_diff_ncp_param))
```

- Inertia
```{r}
(Conf_Mat_PELT_ine_ncp <- conf_matrix_ncp(pred_CPs = locat_PELT_ncp_ine, true_CPs = true_ncp, 
                        window_parameters = fixmw_ine_ncp_param))
```

- Outdegree Sender
```{r}
(Conf_Mat_PELT_out_ncp <- conf_matrix_ncp(pred_CPs = locat_PELT_ncp_out, true_CPs = true_ncp, 
                        window_parameters = fixmw_out_ncp_param))
```

### BS

- Sender Effect
```{r}
(Conf_Mat_BS_send_ncp <- conf_matrix_ncp(pred_CPs = locat_BS_ncp_send, true_CPs = true_ncp, 
                        window_parameters = fixmw_send_ncp_param))
```

- Diference
```{r}
(Conf_Mat_BS_diff_ncp <- conf_matrix_ncp(pred_CPs = locat_BS_ncp_diff, true_CPs = true_ncp, 
                        window_parameters = fixmw_diff_ncp_param))
```

- Inertia
```{r}
(Conf_Mat_BS_ine_ncp <- conf_matrix_ncp(pred_CPs = locat_BS_ncp_ine, true_CPs = true_ncp, 
                        window_parameters = fixmw_ine_ncp_param))
```

- Outdegree Sender
```{r}
(Conf_Mat_BS_out_ncp <- conf_matrix_ncp(pred_CPs = locat_BS_ncp_out, true_CPs = true_ncp, 
                        window_parameters = fixmw_out_ncp_param))
```

**The REH with 1 CPs in inertia**

Assign the true CP for one changepoint in `inertia`
```{r}
# windowss contain the CPs time point 56, 57, 58 in inertia
true_1cp <- matrix(47:67, nrow = 21, ncol = 1)
```

### BOCPD

- Sender Effect
```{r}
(Conf_Mat_send_1cp <- conf_matrix_ncp(pred_CPs = locat_BOCD_1cp_send, true_CPs = true_ncp, 
                        window_parameters = fixmw_send_1cp_param))
```

- Diference
```{r}
(Conf_Mat_diff_1cp <- conf_matrix_ncp(pred_CPs = locat_BOCD_1cp_diff, true_CPs = true_ncp, 
                        window_parameters = fixmw_diff_1cp_param))
```

- Inertia
```{r}
(Conf_Mat_ine_1cp <- conf_matrix_cp(pred_CPs = locat_BOCD_1cp_ine, true_CPs = true_1cp, 
                        window_parameters = fixmw_ine_1cp_param))
```

- Outdegree Sender
```{r}
(Conf_Mat_out_1cp <- conf_matrix_ncp(pred_CPs = locat_BOCD_1cp_out, true_CPs = true_ncp, 
                        window_parameters = fixmw_out_1cp_param))
```

### PELT

- Sender Effect
```{r}
(Conf_Mat_PELT_send_1cp <- conf_matrix_ncp(pred_CPs = locat_PELT_1cp_send, true_CPs = true_ncp, 
                        window_parameters = fixmw_send_1cp_param))
```

- Diference
```{r}
(Conf_Mat_PELT_diff_1cp <- conf_matrix_ncp(pred_CPs = locat_PELT_1cp_diff, true_CPs = true_ncp, 
                        window_parameters = fixmw_diff_1cp_param))
```

- Inertia
```{r}
(Conf_Mat_PELT_ine_1cp <- conf_matrix_cp(pred_CPs = locat_PELT_1cp_ine, true_CPs = true_1cp, 
                        window_parameters = fixmw_ine_1cp_param))
```

- Outdegree Sender
```{r}
(Conf_Mat_PELT_out_1cp <- conf_matrix_ncp(pred_CPs = locat_PELT_1cp_out, true_CPs = true_ncp, 
                        window_parameters = fixmw_out_1cp_param))
```

### BS

- Sender Effect
```{r}
(Conf_Mat_BS_send_1cp <- conf_matrix_ncp(pred_CPs = locat_BS_1cp_send, true_CPs = true_ncp, 
                        window_parameters = fixmw_send_1cp_param))
```

- Diference
```{r}
(Conf_Mat_BS_diff_1cp <- conf_matrix_ncp(pred_CPs = locat_BS_1cp_diff, true_CPs = true_ncp, 
                        window_parameters = fixmw_diff_1cp_param))
```

- Inertia
```{r}
(Conf_Mat_BS_ine_1cp <- conf_matrix_cp(pred_CPs = locat_BS_1cp_ine, true_CPs = true_1cp, 
                        window_parameters = fixmw_ine_1cp_param))
```

- Outdegree Sender
```{r}
(Conf_Mat_BS_out_1cp <- conf_matrix_ncp(pred_CPs = locat_BS_1cp_out, true_CPs = true_ncp, 
                        window_parameters = fixmw_out_1cp_param))
```






















confusion matrix

```{r}
true_cp <- matrix(data = c(58, 59, 60, 61, 62, 63, 57, 56, 55, 54, 53), ncol = 1)
true_cp <- matrix(, nrow = 1, ncol = 0)
a <- conf_matrix(pred_CPs = locat_BOCD_ncp_ine, true_CPs = true_cp, window_parameters = fixmw_ine_ncp_param)
```


MSE

```{r}
c <- MSE_CPD(pred_CPs = locat_BOCD_1cp_ine, true_CPs = 57, range = 5)

c <- MSE_CPD(pred_CPs = locat_BOCD_2cp_ine, true_CPs = c(24, 77), range = 5)
```

MSD

```{r}
d <- MSD_CPD(pred_CPs = locat_BOCD_1cp_ine, true_CPs = 57, range = 5)

d <- MSD_CPD(pred_CPs = locat_BOCD_2cp_ine, true_CPs = c(24, 77), range = 5)
```










